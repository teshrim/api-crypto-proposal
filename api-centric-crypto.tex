\section{API-centric Cryptography}
The security community has published extensively on the \emph{usability} of
APIs~\cite{ABF+}\todo{we should have more than one citation}. 
Intuitively, if an API is easy to use correctly, developers are more
likely to build secure applications to top of it.  
%
Our approach is complementary, focusing on the relationships between
functionalities that APIs present (to application developers) and the primitives
that crypto theory provides. We take the position that, in practice, APIs are
primarily driven by non-security requirements (e.g. functionality, adoption,
deployment).
%
As such, it is emcumbent upon us to take an \emph{API-centric} view of the
primitives we formalize.

\paragraph{Prior Work.}
In~\cite{SSW}, PI Shrimpton gave a provable-security treatment to the design and
analysis of so-called ``cryptographic APIs'', standardized in the PKCS\#11
document\cite{xxx}.  That standard details an interface by which one may interact
cryptographic tokens (e.g. smart cards, USB devices, enterprise-grade HSMs) that
are trusted to perform key-manangement duties, enforcement of policies for the
use of stored keys, and a limited number of asymmetric- and symmetric-key crypto
operations.  These tokens support a variety of applications, including
certification authorities, SSL/TLS acceleration, and interbank communication.

Our approach in this paper was API-centric, in that we took the PKCS\#11
standard as the reference point, and defined from it a new cryptographic-API
primitive.  We then formalized some of the intuitive notions of security for a
cryptographic API.  This was a complex undertaking, as one of the core
key-management functionalities is to allow the exporting and importing of keys
via ``key (un)wrapping'' operations.  (This supports, among other things, the
transportation of cryptographically protected keys between tokens.)  These keys
may have a variety of attributes associated to them that proscribe
their usage, e.g. this key may/may not be used to encrypt data (via a given API
call), this key may/may not be wrapped for future export.  Thus, the internal
state of the key-management functionality changes as an attacker carries out
permitted API calls. \todo{Mention the API-attack papers by Graham
  Steele.} 
Moreover, a real adversary may be in possession of one or
more tokens ---~keep in mind that these may be physically vulnerable
devices, such as USB sticks or smart cards~--- and these are subject
to corruption.  As a result, a victim token is asked to
import adverasarially-known keys.  This can cause many other keys
under management by the victim to become (effectively) corrupted, 
e.g. if the attributes of the imported key allow it to be used for wrapping.


%
Recent work by PI Shrimpton~\cite{BPS} revisits the theory of
hedged public-key encryption (PKE)~\cite{BBN+} from an API-centric perspective.
%
The motivation for hedged PKE is quite practical. Traditional
PKE schemes are proved secure under the assumption that they have access to a
source of uniform random bits; but in practice, PKE schemes are implemented on
systems that have faulty RNGs, or where entropy is difficult to harvest.  In
these cases, the security guarantees proved in theory are, at best, voided; at
worst, failure of the RNG can lead to recovery of the plaintext.
%
Hedged PKE is designed to satisfy traditional notions of security when provided
uniform randomness, and still deliver useful security properties as the quality
of randomness degrades.  The most elegant construction of hedged PKE works like
this: synthesize fresh random bits by hashing all of the encryption inputs (the
public key, the message, the provided randomness), and then use these bits as
the randomness for an underlying PKE scheme.  In practice, implementing this
simple construction is surprisingly difficult, as the high- and mid-level APIs
presented by the most commonly used crypto libraries (e.g. OpenSSL and
significant forks thereof) \emph{do not} permit one to specify the
per-encryption randomness.   In~\cite{BPS}, the theory of hedged PKE is
reconsidered from the perspective of what can be easily constructed given what
real APIs expose, and what provable security guarantees these can achieve.

\paragraph{Tasks.} \tsnote{List of possible tasks}
\begin{itemize}
\item As a first step towards respecting real APIs, we must understand the extent to
which the primitives we formalize in theory align with the actual primitives
that APIs expose to developers. \tsnote{Survey, SoK-type work.}
\item {Application developer APIs for secure send/receive of messges
(data-in-flight) and secure read/write from storage (data-at-rest).  What are
the implied primitives, and what are the security properties that developers
assume are provided.}
\item {Secure-channel APIs for streaming data vs.
message-oriented data.}  \todo{Look at ``data is a stream'' paper.}

  \item \emph{Authenticated key-exchange.}
    %
    Bellare and Rogaway~\cite{bellare1993entity} were the first to formalize the
    goal of authenticated key exchange. Since their seminal work (Crypto `93),
    the setting in which we analyze the security of these protocols has not
    changed much; meanwhile, the needs of real-world protocols have evolved
    substantially over the years. Take TLS as an example.
    %
    First, the vast majority of the literature has focused on the case of
    \emph{mutual} AKE (MAKE), where both client and server wish to authenticate the
    other. In fact, virtually all TLS handshakes on the Internet are only
    \emph{unilaterally} authenticated (UAKE)~\cite{xxx}. (The client
    wishes to verify the server's identity.)
    %
    Second, TLS offers features that break with the Bellare-Rogaway model
    altogether. For example, Bhargavan et al.~\cite{bhargavan2014proving} point
    out (a) that handshakes share states \emph{across session} (in
    Bellare-Rogaway each session has its own state), and that (b) the same
    material may be used by the same entity in \emph{different protocols}
    (requires the underlying algorithms be \emph{agile}, a
    la~\cite{acar2010cryptographic}).
    %
    Third, an important consideration in the upcoming TLS 1.3
    specification~\cite{tls13} is \emph{session resumption}, where the goal is
    to piggy-back a fresh key exchange on the data channel between a client and
    server who have already performed the full handshake. This feature is
    crucial from an engineering perspective, but as is well-known~\cite{xxx}, we
    cannot provide the same level of security for the message on which we are
    piggy-backing the exchange as is possible for subsequent messages.

    These issues (and a myriad of others) point to a gap between how programmers
    expect they should be able to use cryptography, and how cryptography
    is to be used securely. This presents an opportunity to distill from design
    patterns in existing KE protocols (TLS, IPSec, Signal, Noise, etc.) an
    abstraction (and corresponding API) that cleanly captures the needs of
    software engineers.
    %
    A promising direction is to begin with Dodis and
    Fiore~\cite{dodis2017unilateral}, who show that security in this setting is
    much easier to model than the more general MAKE setting of Bellare-Rogaway.
    Motivated by the design of TLS 1.3, Krawczyk
    recently~\cite{krawczyk2016unilateral-to-mutual} showed how to transform any
    (natural) UAKE scheme to a MAKE scheme.

\item {Close open questions from CrAPI paper}
\end{itemize}

%\paragraph{Prior Work.}