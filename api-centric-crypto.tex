\section{API-centric Cryptography}
The security community has published extensively on the \emph{usability} of
APIs~\cite{ABF+}\todo{we should have more than one citation}.  Intuitively, if
an API is easy to use correctly, developers are more likely to build secure
applications on top of it.
%
Our approach is complementary, focusing on the relationships between
functionalities that APIs present (to application developers) and the primitives
that crypto theory provides. We take the position that, in practice, APIs are
primarily driven by non-security requirements (e.g. functionality, adoption,
deployment).
%
As such, it is emcumbent upon us to take an \emph{API-centric} view of the
primitives and protocols that we formalize.  
In the remainder of this section, we discuss specific
areas to which we will apply this API-centric perspective.  
%Note that this is a preliminary list of areas, based on prior results and current considerations.

\paragraph{Understanding an APIs customers. }
It is important to recognize that there are at least two types of ``customers'' to consider 
when taking an API-centric viewpoint on cryptography.   The first we have already mentioned, 
namely application developers.  Application developers are largely concerned about functionality,
and have relatively little expertise in cryptography.  They are likely to want a simple,
semantically intuitive, high-level interface, e.g. 
\begin{align*}
\varfont{SocketHandle}&\gets\algfont{SecureOpen}(\varfont{ReceiverID}), \\
\varfont{Status}&\gets\algfont{SecureSend}(\varfont{SocketHandle, Msg}),\\
\varfont{Msg}&\gets\algfont{SecureReceive}(\varfont{SocketHandle}), \\
\varfont{Status}&\gets\algfont{SecureClose}(\varfont{SocketHandle}).
\end{align*}
%
where the type and structure of the data object \varfont{Msg} would be separately specified, e.g. it may 
include associated data or attributes, in addition to the actual plaintext.
%
The second type of consumer is a security engineer.  We expect security engineers to have (at least)
a reasonable understanding of basic cryptography and cryptographic/security hygiene.  They are
likely to want some degree of control over algorithmic and parameter choices.  Security engineers also
need the API to be flexible enough to support a broad range of applications.   [...]
\cpnote{Why discuss the two customers? Who are we trying to help?}


\begin{task}
 As a first step towards respecting real APIs, we must understand the extent to
which the primitives we formalize in theory align with the actual primitives
that APIs expose to developers. \tsnote{Survey, SoK-type work.}
\end{task}




\paragraph{Standardized APIs. }
In~\cite{SSW}, PI Shrimpton gave a provable-security treatment to the design and
analysis of so-called ``cryptographic APIs'', standardized in the PKCS\#11
document\cite{xxx}.  That standard details an interface by which one may interact
cryptographic tokens (e.g. smart cards, USB devices, enterprise-grade HSMs) that
are trusted to perform key-manangement duties, enforcement of policies for the
use of stored keys, and a limited number of asymmetric- and symmetric-key crypto
operations.  These tokens support a variety of applications, including
certification authorities, SSL/TLS acceleration, and interbank communication.

Our approach in this paper was API-centric, in that we took the PKCS\#11
standard as the reference point, and defined from it a new cryptographic-API
primitive.  We then formalized some of the intuitive notions of security for a
cryptographic API.  This was a complex undertaking, as one of the core
key-management functionalities is to allow the exporting and importing of keys
via ``key (un)wrapping'' operations.  (This supports, among other things, the
transportation of cryptographically protected keys between tokens.)  These keys
may have a variety of attributes associated to them that proscribe
their usage, e.g.\ this key may/may not be used to encrypt data (via a given API
call), this key may/may not be wrapped for future export.  Thus, the internal
state of the key-management functionality changes as an attacker carries out
permitted API calls. (We note that works by Steele and coauthors~\cite{xxx,yyy,zzz} exploit this
changing of internal state, sometimes in concert with underspecification in standards and device documentation,
to cause catastrophic security breaks in HSMs.)
Moreover, a real adversary may be in possession of one or
more tokens ---~keep in mind that these may be physically vulnerable
devices, such as USB sticks or smart cards~--- and these are subject
to corruption.  As a result, a victim token is asked to
import adverasarially-known keys.  This can cause many other keys
under management by the victim to become (effectively) corrupted, 
e.g. if the attributes of the imported key allow it to be used for wrapping.
\todo{Write something about open questions from that paper.}

\begin{task}
[Close open questions from CrAPI paper]
\end{task}
%

\paragraph{Hedged Cryptography. }
Recent work by PI Shrimpton~\cite{BPS} revisits the theory of
hedged public-key encryption (PKE)~\cite{BBN+} from an API-centric perspective.
%
The motivation for hedged PKE is quite practical. Traditional
PKE schemes are proved secure under the assumption that they have access to a
source of uniform random bits; but in practice, PKE schemes are implemented on
systems that have faulty RNGs, or where entropy is difficult to harvest.  In
these cases, the security guarantees proved in theory are, at best, voided; at
worst, failure of the RNG can lead to recovery of the plaintext.
%
Hedged PKE is designed to satisfy traditional notions of security when provided
uniform randomness, and still deliver useful security properties as the quality
of randomness degrades.  The most elegant construction of hedged PKE works like
this: synthesize fresh random bits by hashing all of the encryption inputs (the
public key, the message, the provided randomness), and then use these bits as
the randomness for an underlying PKE scheme.  In practice, implementing this
simple construction is surprisingly difficult, as the high- and mid-level APIs
presented by the most commonly used crypto libraries (e.g. OpenSSL and
significant forks thereof) \emph{do not} permit one to specify the
per-encryption randomness.   In~\cite{BPS}, the theory of hedged PKE is
reconsidered from the perspective of what can be easily constructed given what
real APIs expose, and what provable security guarantees these can achieve.

\begin{task}
\todo{CHRIS: can you please write up a short (2-3 paragraph) discussion about the follow-on work we want to do for the hedged crypto effort?}
\end{task}

\paragraph{Secure Channels. }
Even as the theory of cryptography grows to encompass newer and more exotic
challenges, providing a secure channel remains far and away its most mportant
task.
%
Today, TLS is deployed by ??\% of web servers and protects ??\% of
communications on the Internet. As such, this crucial code has been scrutinized
from top to bottom, including the crypto, the protocol specification,
implementations, and its deployment.\footnote{ See the \textsc{miTLS} project
for an overview: \url{https://www.mitls.org}.}
%
Academic papers on the (in)security of TLS fall braodly into three categories:
those focusing on the TLS \emph{handshake} (unilateral- or
mutually-authenticated key exchange)~\cite{BNF+14,others}, the \emph{record
layer} (the protocol encapsulating application data)~\cite{PRS11}, or the
composition of the two~\cite{JKSS12,KPW13}. This work will focus on the TLS
record layer.

Over the last decade or so, \emph{authenticated encryption with associated data}
(AEAD) has emerged as an important ingredient for constructing secure channels.
%
Its syntax is easy to reason about from a theoretical point of view, but is
robust enough to encompass most tasks that practitioners encounter. Moreover,
notions like \emph{nonce-misuse resistant}~\cite{RS07} and
\emph{robust}~\cite{HKR14} authenticated encryption make AEAD schemes difficult
to (inadvertently) use incorrectly. These properties make AEAD an attractive
tool for designing protocols; indeed, schemes like AES-GCM and
ChaCha20\mbox{-}Poly1305 are baked into the upcoming TLS 1.3
specification.\footnote{ See \url{https://tlswg.github.io/tls13-spec}.}
%
\cpnote{AFAIK AES-GCM is \emph{not} nonce-misuse resistant ... not sure about
ChaCha20. Are there other AEADs in the spec?}
%
It is tempting to think that AEAD, on its own, provides a secure channel. In
fact, for the thing to be useful for communicating over a network, we need to
specify a protocol in which it is used. The choice of protocol is driven largely
by engineering considerations, such as bandwidth constrains, computational
resources, and implementation complexity. However, the choice is also crucial
for security; time and time again, bugs in the \emph{protocol logic} have been
exploited to \emph{completely circumvent} the security provided by the
underlying crypto~\cite{BKN02}. These attacks point to a substantial gap between
crypto theory and the complexity of protocol logic.

We are by no means the first to point out this gap. It was recenlty observed by
Badertscher \etal~\cite{BMM+15} that the implicit goal of the TLS 1.3
record layer protocol is to construct an ``augmented'' secure channel (ASC), which
provide the capability of sending a message with two parts: the first being
private, and both parts being authenticated. They emphasize that classical
security notions, such as those for AEAD, ``do not capture in which contexts a
scheme satisyfying them can securely be used. They consider a specific attack
model and give certain capabilitiles to an adversry that tries to win some game,
but it is not \apriori clear which capababilities an adversary has in a
particular application, or even what her final goal is.'' \cite[pp. 2]{BMM+15}.
Nevertheless, this work (and others like it~\cite{BKN02,PRS11}) omit an important
detail.

\emph{Data is a stream \cite{FPMG15}.}
Providing a reliable (but not secure) channel between any two hosts on the Internet
is the job of the TCP/IP protocol stack. TCP in particular is designed so that
application developers need not worry about the details at all.
%
Conceptually, the API exports a stream-like functionality in which the sender
stuffs in any number of bytes and expects that they are read in order by the
sener.
%
In C, the sender sends data by invoking a function \codefont{send()}, which
takes as input its socket identifier, a buffer containing the data
\emph{fragment}, the fragment length (in bytes), and some flags; the output
indicates the number of bytes written to the channel, or an indication of
failure. The receiver invokes \codefont{recv()}, which takes as input its socket
identifier, a buffer, the maximum number of bytes to read from the stream, and
some flags. It returns the number of bytes read or an indication of failure.
%
Virtually all programming languages export a similar API for streaming data. The
alternative view (and the conventional wisdom of the cryptographic community) is
that channels provide transport of a sequence of discrete messages between two
parties. Of course, this is the true for datagram-based transport (UDP), but it
is not true for TCP.

The latter is ubiquitous for the delivery of web content; consequently,
implementations of the TLS record layer export a streaming API. In OpenSSL (the
most widely-deployed implementation of TLS), \codefont{SSL\_write()} is used to
write bytes to the stream and \codefont{SSL\_read()} is used to read bytes from
the stream. Although their syntax differes,\footnote{ See
\url{https://wiki.openssl.org/index.php/Manual:SSL_write(3)}.} these have the
same semantics as \codefont{send()} and \codefont{recv()} defined above. Thus,
the programmer can use this API just as she would use the lower-level
functionality for reliable transport, but with the added assurance that the
channel is secure.

Fischlin \etal~\cite{FPMG15} were the first (at least in our community) to
elucidate secure channels as a data stream. \cpnote{This is still a work in
progress.}

\begin{task}
Secure-channel APIs for streaming data vs.message-oriented data. 
\end{task}

\begin{task}
 \todo{This needs lead in text!}
Application developer APIs for secure send/receive of messges
(data-in-flight) and secure read/write from storage (data-at-rest).  What are
the implied primitives, and what are the security properties that developers
assume are provided.
\end{task}

\paragraph{Authenticated Key-Exchange. } \tsnote{Chris' text.}
    Bellare and Rogaway~\cite{bellare1993entity} were the first to formalize the
    goal of authenticated key exchange. Since their seminal work (Crypto `93),
    the setting in which we analyze the security of these protocols has not
    changed much; meanwhile, the needs of real-world protocols have evolved
    substantially over the years. Take TLS as an example.
    %
    First, the vast majority of the literature has focused on the case of
    \emph{mutual} AKE (MAKE), where both client and server wish to authenticate the
    other. In fact, virtually all TLS handshakes on the Internet are only
    \emph{unilaterally} authenticated (UAKE)~\cite{xxx}. (The client
    wishes to verify the server's identity.)
    %
    Second, TLS offers features that break with the Bellare-Rogaway model
    altogether. For example, Bhargavan et al.~\cite{bhargavan2014proving} point
    out (a) that handshakes share states \emph{across session} (in
    Bellare-Rogaway each session has its own state), and that (b) the same
    material may be used by the same entity in \emph{different protocols}
    (requires the underlying algorithms be \emph{agile}, a
    la~\cite{acar2010cryptographic}).
    %
    Third, an important consideration in the upcoming TLS 1.3
    specification~\cite{tls13} is \emph{session resumption}, where the goal is
    to piggy-back a fresh key exchange on the data channel between a client and
    server who have already performed the full handshake. This feature is
    crucial from an engineering perspective, but as is well-known~\cite{xxx}, we
    cannot provide the same level of security for the message on which we are
    piggy-backing the exchange as is possible for subsequent messages.

    These issues (and a myriad of others) point to a gap between how programmers
    expect they should be able to use cryptography, and how cryptography
    is to be used securely. This presents an opportunity to distill from design
    patterns in existing KE protocols (TLS, IPSec, Signal, Noise, etc.) an
    abstraction (and corresponding API) that cleanly captures the needs of
    software engineers.
    %
    A promising direction is to begin with Dodis and
    Fiore~\cite{dodis2017unilateral}, who show that security in this setting is
    much easier to model than the more general MAKE setting of Bellare-Rogaway.
    Motivated by the design of TLS 1.3, Krawczyk
    recently~\cite{krawczyk2016unilateral-to-mutual} showed how to transform any
    (natural) UAKE scheme to a MAKE scheme.

\begin{task}
\todo{CHRIS: can you pull out a concrete task?}
\end{task}
    %
