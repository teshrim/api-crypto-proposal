\section{Implementation-considerate Formalisms}
The modern ``provable security'' approach to cryptography loosely follows a
three-step recipe: define a precise syntax for the abstract primitive under
study, define formal notions of security for that primitive, realize the
primitive and prove it meets the security notions.  The first step, defining the
syntax, essentially defines the component objects that collectively make up the
primitive, e.g. ``An encryption scheme $\Pi=(\calK,\calE,\calD)$ is a triple of
algorithms...''  The syntax typically describes the number and type of the
inputs and outputs of these components, too, e.g. ``The decryption algorithm
provides a mapping $\calD\colon\bits^{k}\times\bits^* \to \bits^* \cup
\{\bot\}$...'', as well as requirements on the behavior of these components in
any correct realization of them.

%\cpnote{This is great.}
%
In a sense, the syntax for a new primitive provides an API for researchers: for
those wishing to \emph{realize} the primitive (in theory), it makes clear what
are the functionalites that must be realized, and what are the assertions that
must hold for any realization; for those wishing to \emph{use} the primitive, it
makes clear what calls will be available to them, and what are the expected
inputs and outputs of those calls.
%
Like a real software API, syntax is considered good if it serves the needs of
its ``customers''; in this case, if it supports clear security notions, facilitates the
writing (and verification) of proofs, and is easily built upon.
\footnote{As an aside, PI Shrimpton has found the analogy of
  \emph{syntax-as-API} as a useful pedagogical tool.  Computer science
  students often seem far more familiar and comfortable with
  programming abstractions than with mathematical ones.}

%Of course, this analogy only goes so far.  When a researcher argues for a change
%to the accepted syntax ---~a new API for a primitive~--- there is no real cost
%incurred if it is adopted.  Prior works using the old syntax do not
%suddenly``break''; in the worst case they may (eventually) be viewed as
%outdated.  If anything, the new syntax presents an opportunity for researchers
%revisit prior work and publish updated findings.

%\cpnote{I think you should add a nonce to the AEAD syntax below, as I think is
%usual. This also gives you an opportunity to discuss the issue with nonces in
%practice: that there's not always an obvious choice for a nonce, programmer's
%don't know how/why to use them, etc.}
%
Of course, there is a considerable gap between the formal syntax that papers
provide and a \emph{real} API, i.e. the functionalities that need to be
implemented.  For example, consider the the formal syntax for symmetric-key
decryption with associated data, $\calD\colon\calK \times \calH \times \bits^*
\to \bits^* \cup \{\bot\}$.  We cryptographers would typically write something
like $M \gets \calD^H_K(C)$ for the decryption of ciphertext~$C\in\bits^*$, with
associated data~$H \in \calH$, under key~$K \in \calK$.  But this quietly
assumes a number of implicit functionalities that must be attended to in
practice.

First of all, the formal syntax assumes that $H,C$ are simply presented as
inputs.  In reality the decryption process needs to parse (aka
deserialize, unmarshall) what is received from
the channel into the ciphertext~$C$ and any context information (aka associated
data) that was sent with~$C$.  Moreover, the
overall decryption process may depend on both the context that is associated to
this ciphertext transmission \emph{and} on context that the receiver maintains
for the channel. (Note that the syntax is silent on the source of the associated
data.)  In practice the receiver may maintain local message counters, lists of
nonces already observed on the channel, information about the overall status and
health of the channel (e.g. is it still considered active), and so on.  The
decryption key~$K$ is also part of the context that the receiver maintains.

Next, the formal syntax says that decryption returns a
string or a distinguished symbol~$\bot$, the latter being traditionally
understood by cryptographers to mean ``invalid''.  In practice, this means that
some logic must be implemented to decide (in)validity, and that when the
decision is ``invalid'' some error-handling mechanism ensures that the
decryption process returns nothing but a distinguished error message.

In Figure~\ref{fig:syntax-api-example}, we give an example of a more
API-like presentation of decryption.
%
Making these implied functionalities more explicit has several benefits.  The
most obvious is helping developers to see what they need to implement, rather
than assuming they will be able to correctly tease out what's needed.
Conversely, it prompts the theoretician to think in terms of abstractions that
appear in practice.
%
For both developer and theoretician, this style of presentation can surface a
clearer picture of what security demands of these functionalities. For example,
specifying error handling as an explicit functionality\footnote{Following Rogaway and Stegers~\cite{RS09}, variables are
passed by value except where annotated by \rwordfont{var}.}
\[
\varfont{ExternalVals} \gets
                                  \algfont{ErrHandler}(\rwordfont{var}
                                  \varfont{ChannelContext},
                                  \varfont{StatusMsg}, \varfont{ExternalVals})
\]
more naturally prompts one to consider questions, like, what \varfont{ExternalVals} should
be returned for a given \varfont{StatusMsg}, and what
security-relevant information might be leaked by them?  How should the
\varfont{ChannelContext} be updated for a given \varfont{StatusMsg}?

In Figure~\ref{fig:EtM-aead} we give two potential realizations of the
functions needed for decryption, in particular of an Encrypt-then-MAC
style AEAD decrpytion.  On the left side of the figure, we
give a realization that follows what we theoreticians consider as best
practice.  Namely, if the tag check fails, then one should label the
ciphertext as invalid, and suppress all output other than the (single)
error message ``Invalid'' (or $\bot$ in typical syntax).


\tsnote{Say that this may seem like overkill for ``simple'' primitives
like symmetric-key decryption, but that (1) it only seems that way
because we are already implicitly thinking about what it means for
things to be valid, etc., and (2) we ``know'' not to do certain things
because mistakes were made in the past, by people who didn't know at
the time --- hindsight is 20-20.}

\begin{task}
{We will reconsider the traditional formalisms for cryptographic primitives from an implementation-considerate perspective, and establish security notions with respect to the new syntax. }
\end{task}

\tsnote{Need to address head-on the complaint that this is going to
  make for more complicated analysis.}

\paragraph{Prior Work. }
%
\todo{Look at Rogaway's online-AE paper.  I seem to remember him
  saying that the main contribution of that paper was API oriented}
\cpnote{\cite[Section 5]{HRRV15}: ``We provie a new notion for online-AE ... To
accurately model the underlying goal, not only must the security definition
depart from [prior work], but so too must a scheme's basic syntax. In
particular, we adopt an API-based view, where the segmentation of a plaintext is
determined by the caller.''}

\include{syntax-api-example}
