\section{Implementation-considerate Formalisms}
The modern ``provable security'' approach to cryptography loosely follows a
three-step recipe: define a precise syntax for the abstract primitive under
study, define formal notions of security for that primitive, realize the
primitive and prove it meets the security notions.  The first step, defining the
syntax, essentially defines the component objects that collectively make up the
primitive, e.g. ``An encryption scheme $\Pi=(\calK,\calE,\calD)$ is a triple of
algorithms...''  The syntax typically describes the number and type of the
inputs and outputs of these components, too, e.g. ``The encryption algorithm
provides a mapping $\calE \colon\bits^{k}\times\bits^* \to \bits^* \cup
\{\bot\}$...'', as well as requirements on the behavior of these components in
any correct realization of them.

%\cpnote{This is great.}
%
In a sense, the syntax for a new primitive provides an API for researchers: for
those wishing to \emph{realize} the primitive (in theory), it makes clear what
are the functionalites that must be realized, and what are the assertions that
must hold for any realization; for those wishing to \emph{use} the primitive, it
makes clear what calls will be available to them, and what are the expected
inputs and outputs of those calls.
%
Like a real software API, syntax is considered good if it serves the needs of
its ``customers''; in this case, if it supports clear security notions, facilitates the
writing (and verification) of proofs, and is easily built upon.
%
%Like a real software API, syntax for a given cryptographic primitive tends to
%have a long life-time (albeit for very different reasons).
%
\ignore{
  Follow-on work typically adopts it, and concerns itself with ``flashier''
  tasks, such as proving tighter security bounds, finding more efficient
  realizations, or moving from an idealized model (e.g. the random-oracle model)
  to the standard model.
}
\footnote{As an aside, PI Shrimpton has found the analogy of
  \emph{syntax-as-API} as a useful pedagogical tool.  Computer science
  students often seem far more familiar and comfortable with
  programming abstractions than with mathematical ones.}

%Of course, this analogy only goes so far.  When a researcher argues for a change
%to the accepted syntax ---~a new API for a primitive~--- there is no real cost
%incurred if it is adopted.  Prior works using the old syntax do not
%suddenly``break''; in the worst case they may (eventually) be viewed as
%outdated.  If anything, the new syntax presents an opportunity for researchers
%revisit prior work and publish updated findings.

%\cpnote{I think you should add a nonce to the AEAD syntax below, as I think is
%usual. This also gives you an opportunity to discuss the issue with nonces in
%practice: that there's not always an obvious choice for a nonce, programmer's
%don't know how/why to use them, etc.}
%
Of course, there is a considerable gap between the formal syntax that papers
provide and a \emph{real} API, i.e. the functionalities that need to be
implemented.  For example, consider the syntax $\calD\colon\calK
\times \calV \times \calH \times \bits^*
\to \bits^* \cup \{\bot\}$ for the decryption
algorithm in an IV-based AEAD scheme~\cite{NPS14}.  We cryptographers would typically write something
like $M \gets \calD^{V,H}_K(C)$ for the decryption of
ciphertext~$C\in\bits^*$, with IV~$V \in \calV$ and
associated data~$H \in \calH$, under key~$K \in \calK$.  But this quietly
assumes a number of implicit functionalities that must be attended to in
practice.

First of all, the formal syntax assumes that $V,H,C$ are simply presented as
inputs.  In reality the decryption process needs to parse
(deserialize) what is received from
the channel into the ciphertext and any context information (aka associated
data) that was sent with it.  Moreover, the
overall decryption process may depend on both the context that is associated to
\emph{this} ciphertext transmission \emph{and} on context that the receiver maintains
for the channel. (Note that the syntax is silent on the source of the associated
data.)  In practice the receiver may maintain local message counters, lists of
IVs already observed on the channel, information about the overall status and
health of the channel (e.g. is it still considered active), and so on.  The
decryption key~$K$ is also part of the context that the receiver maintains.

Next, the formal syntax says that decryption returns a
string or a distinguished symbol~$\bot$, the latter being traditionally
understood by cryptographers to mean ``invalid''.  In practice, this means that
some logic must be implemented to decide (in)validity, and that when the
decision is ``invalid'' some error-handling mechanism ensures that the
decryption process returns nothing but a distinguished error message.

In Figure~\ref{fig:syntax-api-example}, we give an example of a more
API-like presentation of decryption.
%
Making these implied functionalities more explicit has several benefits.  The
most obvious is helping developers to see what they need to implement, rather
than assuming they will be able to correctly tease out this information.
Conversely, it prompts the theoretician to think in terms of practical
abstractions.
%

For both developer and theoretician, this style of presentation can surface a
clearer picture of what security demands of these functionalities. For example,
specifying error handling as an explicit functionality
\[
(\varfont{ChannelContextUpdates}, \varfont{ExternalVals}) \gets
                                  \algfont{ErrorHandling}(%\varfont{ChannelContext},
                                  \varfont{StatusMsg}, \varfont{ExternalVals})
\]
forces one to ask questions, like, what \varfont{ExternalVals} should
be returned for a given \varfont{StatusMsg}, and what
security-relevant information might be leaked by them?  How should the
\varfont{ChannelContext} be updated for a given \varfont{StatusMsg}?

%

\tsnote{I'm no longer convinced this next bit (and the corresponding
  figure) is useful.  It's not clear what interesting things the
  realization on the right surfaces.  It is clearly broken relative to
  standard integrity notions; it has not one, but a massive number of
  ``error messages'' (plaintext $\concat$ ``Warning: TagFail'').  Not
  sure what to do with it -- punt it?  Switch to another primitive?}
In Figure~\ref{fig:EtM-aead} we give two potential realizations of the
functions needed for decryption, in particular of an Encrypt-then-MAC
style AEAD decrpytion.  On the left side of the figure, we
give a realization that follows what we theoreticians consider as best
practice.  Namely, if the tag check fails, then one should label the
ciphertext as invalid, and suppress all output other than the (single)
error message ``Invalid'' (or $\bot$ in typical syntax).~\footnote{A
  variation on this would compute the ciphertext only if the tag check
succeeds.}
%
On the right side of the figure is a realization that can be found in
practice.  Here a tag-check failure results only in a warning message
being attached to the decrypted plaintext, but in any case the
plaintext is returned.  Such behavior may be practically useful in
use-cases (say, a digital audio stream) where a single aberant
ciphertext is tolerable, but tearing down and reestablishing the
channel is not.  In this realization, it is up to the application to
decide what should be the consequences of a tag-check failure.
%
The differing security implications of the two realizations is clearly
visible with this API-like presentation.  Most obviously, on the right
the decryption process offers only ``soft'' protection against integrity attacks.
The application to which the plaintext (and warning) is delivered must
implement its own logic for handling plaintexts that come with
warnings. On the left, the decryption process provides
``hard'' protection to the application layer against integrity attacks.

\ignore{
\tsnote{Say that this may seem like overkill for ``simple'' primitives
like symmetric-key decryption, but that (1) it only seems that way
because we are already implicitly thinking about what it means for
things to be valid, etc., and (2) we ``know'' not to do certain things
because mistakes were made in the past, by people who didn't know at
the time --- hindsight is 20-20.}

\tsnote{Need to address head-on the complaint that this is going to
  make for more complicated analysis.}
}

\include{syntax-api-example}

\begin{task}
{Reconsider the traditional syntax for cryptographic primitives from an implementation-considerate perspective, and establish security notions with respect to the new syntax. }
\end{task}

\paragraph{Prior Work. }
%
\todo{Look at Rogaway's online-AE paper.  I seem to remember him
  saying that the main contribution of that paper was API oriented}

