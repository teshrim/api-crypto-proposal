\section{Implementation-considerate Formalisms}
\tsnote{Most of this came from an earlier approach to writing the
  intro/motivation.  Very drafty.  (As is everything, really, at this point.)}
The modern ``provable security'' approach to cryptrography loosely follows a
three-step recipe: define a precise syntax for the abstract primitive under
study, define formal notions of security for that primitive, realize the
primitive and prove it meets the security notions.  The first step, defining the
syntax, essentially defines the component objects that collectively make up the
primitive, e.g. ``An encryption scheme $\Pi=(\calK,\calE,\calD)$ is a triple of
algorithms...''  The syntax typically describes the number and type of the
inputs and outputs of these components, too, e.g. ``The decryption algorithm
provides a mapping $\calD\colon\bits^{k}\times\bits^* \to \bits^* \cup
\{\bot\}$...'', as well as requirements on the behavior of these components in
any correct realization of them.

In a sense, the syntax for a new primitive provides an API for researchers: for
those wishing to \emph{realize} the primitive (in theory), it makes clear what
are the functionalites that must be realized, and what are the assertions that
must hold for any realization; for those wishing to \emph{use} the primitive, it
makes clear what ``calls'' will be available to them, and what are the expected
inputs and outputs of those calls.
%
Like a real software API, syntax is considered good if it serves the needs of
its consumers, i.e. if it supports clear security notions, facilitates the
writing (and verification) of proofs, and is easily built upon.
%
Like a real software API, syntax for a given cryptographic primitive tends to
have a long life-time (albeit for very different reasons).
%
\ignore{
  Follow-on work typically adopts it, and concerns itself with ``flashier''
  tasks, such as proving tighter security bounds, finding more efficient
  realizations, or moving from an idealized model (e.g. the random-oracle model)
  to the standard model.
}
Indeed, the idea of syntax-as-API is very useful for building intuition, and as
a pedagogical tool.

%Of course, this analogy only goes so far.  When a researcher argues for a change
%to the accepted syntax ---~a new API for a primitive~--- there is no real cost
%incurred if it is adopted.  Prior works using the old syntax do not
%suddenly``break''; in the worst case they may (eventually) be viewed as
%outdated.  If anything, the new syntax presents an opportunity for researchers
%revisit prior work and publish updated findings.

Of course, there is a considerable gap between the formal syntax that
papers provide and a \emph{real} API, i.e. the functionalities that
need to be implemented.  For example, consider the
the formal syntax for symmetric-key decryption with associated data, $\calD\colon\calK
\times \calH \times \bits^* \to \bits^* \cup \{\bot\}$.  We
cryptographers would typically write something like $M \gets
\calD^H_K(C)$ for the decryption of ciphertext~$C\in\bits^*$, with associated
data~$H \in \calH$, under key~$K \in \calK$.  
But this quietly assumes a number of implicit functionalities that
must be attended to in practice.  

First of all, the formal syntax assumes that $H,C$ are simply
presented as inputs.  In reality the decryption process needs to parse what is received from the
channel into the ciphertext~$C$ and any context information (aka
associated data) that was sent with~$C$.\tsnote{mention serialization?}  Moreover, the overall
decryption process may depend on both the context that is associated
to this ciphertext transmission \emph{and} on context that the
receiver maintains for the channel.  (Note that the syntax is silent
on the source of the associated data.)  In practice the receiver may
maintain local message counters, lists of nonces already observed on
the channel, information about the overall status and health of the channel
(e.g. is it still considered active), and so on.  The decryption
key~$K$ is also part of the context that the receiver maintains.

Next, the formal syntax says that decryption returns a
string or a distinguished symbol~$\bot$, the latter being
traditionally understood by cryptographers to mean ``invalid''.  In
practice, this means that some logic must be implemented to decide
(in)validity, and that when the decision is ``invalid'' some
error-handling mechanism ensures that the decryption process returns
nothing but a distinguished error message.

In Figure~\ref{fig:syntax-api-example}, we give an example of a more
API-like presentation of decryption. 
%
We note that making these implied functionalities more explicit has
several benefits.  The most obvious is helping developers to see
what they need to implement, rather than assuming they will be able to
correctly tease out what's needed.  Conversely, it prompts the
theoretician to think in terms of abstractions that appear in
practice.  
%
For both developer and theoretician, this style of presentation can 
surface a clearer picture what security demands of these
functionalities.  For example, specifying error handling as an
explicit functionality
\[
(\varfont{ChannelContextUpdates}, \varfont{ExternalVals}) \gets
                                  \algfont{ErrorHandling}(%\varfont{ChannelContext},
                                  \varfont{StatusMsg}, \varfont{ExternalVals})
\]
forces one to ask questions, like, what \varfont{ExternalVals} should
be returned for a given \varfont{StatusMsg}, and what
security-relevant information might be leaked by them?  How should the
\varfont{ChannelContext} be updated for a given \varfont{StatusMsg}?
In Figure~\ref{fig:EtM-aead} we give to potential realizations of the
functions needed for decryption, in particular of an Encrypt-then-MAC
style AEAD decrpytion.  On the left side of the figure, we
give a realization that follows what we theoreticians consider as best
practice.  Namely, if the tag check fails, then one should label the
ciphertext as invalid, and suppress all output other than the (single)
error message ``Invalid'' (or $\bot$ in typical syntax).


\tsnote{Say that this may seem like overkill for ``simple'' primitives
like symmetric-key decryption, but that (1) it only seems that way
because we are already implicitly thinking about what it means for
things to be valid, etc., and (2) we ``know'' not to do certain things
because mistakes were made in the past, by people who didn't know at
the time --- hindsight is 20-20.}

\tsnote{Need to address head-on the complaint that this is going to
  make for more complicated analysis.}


\include{syntax-api-example}

\begin{task}
{Reconsider the traditional syntax for cryptographic primitives from an implementation-considerate perspective, and establish security notions with respect to the new syntax. }
\end{task}

\paragraph{Prior Work.} 

\todo{Look at Rogaway's online-AE paper.  I seem to remember him
  saying that the main contribution of that paper was API oriented}

